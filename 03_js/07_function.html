<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>

    /*
      함수 작성 방법
      1. 함수 선언(함수 정의)
      2. 함수 표현식
    */
  </script>

  <script>
    /*
      함수 선언(함수 정의)
      1. 함수 이름을 직접 결정하는 방식이다.
      2. 호이스팅된다. (호출->선언 순서여도 무조건 선언 먼저 실행된다.)
      3. 형식
        1) 함수 선언
          function 함수이름([매개변수]) {
            함수본문
            [return 반환값]
          }
        2) 함수 호출
          함수이름([인자])
    */
   
   //myFunc1();
   
   function myFunc1(){
     window.alert('myFunc1 실행');
   }

  </script>
  <script>
    /*
      함수 표현식
      1. 익명 함수(이름 없는 함수)와 이름이 있는 함수를 변수에 저장하는 방식이다.
      2. 호이스팅 되지 않는다. (반드시 표현식을 먼저 작성해야 한다.)
      3. 익명 함수 형식
        1) 함수 표현식
          var 함수이름 = function([매개변수]) {
            함수본문
            [return 반환값]
          }
        2) 함수 호출
          함수이름([인자])
      4. 이름이 있는 함수 형식
        1) 함수 표현식
          var 변수이름 = function 함수이름([매개변수]) {
            함수본문
            [return 반환값]
          }
        2) 함수 호출
          함수이름([인자])
          변수이름([인자])
    */
   
    var myFunc2 = function(){
     window.alert('myFunc2 실행');
    }

    //myFunc2();

  </script>

  <script>

    /*
    ** 인자(argument) 매개변수(parameter) **
      인자와 매개변수
      1. 매개변수를 선언할 때 선언 키워드(var)는 사용하지 않는다.
      2. 매개변수를 선언할 때 매개변수의 이름만 작성한다.
      3. 매개변수의 디폴트 처리가 가능하다.
      4. 인자 객체(arguments)를 지원한다. (arguments : 내장 객체)
      5. 매개변수로 함수를 전달할 수 있다.
         
    */

    // 일반 변수 : 참조 관계 없음
    function myFunc3(number){ // 여기서의 number는 함수 안에서만 사용됨.
      number = number + 1;
    }
    var number = 10;
    console.log(number);
    myFunc3(number);
    console.log(number);

    // 배열 : 참조 관계 있음
    // 참조자료형(주소기반) 변수의 전달로 인해 전달한 배열이 함수 내부에서 직접적으로 수정되었다. 
    function myFunc4(array){
      array[0] = 'Z';
    }
    
    var array = ['A', 'B'];
    console.log(array);
    myFunc4(array);
    console.log(array);

    // 객체 : 참조 관계 있음
    // 참조자료형(주소기반) 변수의 전달로 인해 전달한 객체가 함수 내부에서 직접적으로 수정되었다.
    function myFunc5(obj) {
      obj.maker = '벤츠';
      obj.model = '이클';
    }
    var obj = {
      maker: 'bmw',
      model: '5시리즈'
    };
    console.log(obj);
    myFunc5(obj);
    console.log(obj);

    // 매개변수의 디폴트 처리
    function myFunc6(number){
      // 매개변수 number로 전달된 인자 값이 없으면 number를 0으로 처리한다.
      number = number || 0; // undefined는 false 이므로 OR 뒤 0 이 실행된다.
      console.log(number);
    }

    myFunc6();    // 디폴트 처리 안하면 undefined 출력
    myFunc6(100);

    // 인자 객체(arguments) : 인자를 저장하는 객체, 배열과 유사하게 동작하는 객체(유사 배열)
    function myFunc7(){  // 함수 선언시 매개변수를 지정 안해도 호출할 때 전달하는 인자값이 있을 때 이 인자값을 arguments 객체에 저장한다.
      var total = 0;
      for(var i = 0 ; i < arguments.length; i++){
        total += arguments[i];
      }
      console.log(total / arguments.length);
    }
    myFunc7(1, 2, 3, 4);

    // 매개변수로 함수 전달하기 - 1
    // func = function(){console.log()} 형식
    function myFunc8(func){
      func(); // 전달받은 함수 호출
    }

    // 인자가 없는 익명 함수 전달 (myFunc9 호출부)
    myFunc8(function() {
      console.log('인자가 없는 익명 함수');
    });

    // 매개변수로 함수 전달하기 - 2
    function myFunc9(func, x, y){
      func(x, y);
    }
    
    // 인자가 있는 익명 함수 전달 (myFunc10 호출부)
    myFunc9(function(x, y){
      console.log(x, y);
    }, 'hello', 'world')

  </script>

  <script>

    /*
      반환
      1. 반환 타입을 작성하지 않는다.
      2. return 반환값; 을 통해서 반환할 수 있다.
      3. return; 을 통해서 함수 실행을 종료할 수 있다.
    */

    function myMax(){  // 함수 선언시 매개변수를 지정 안해도 호출할 때 전달하는 인자값이 있을 때 이 인자값을 arguments 객체에 저장한다.
      var max = arguments[0] || 0;    //arguments[0] 이 없으면 0 저장(디폴트 처리)
      for(var i = 1; i < arguments.length; i++){
        if(max < arguments[i]){
          max = arguments[i];
        }
      }
      return max;
    }
    console.log(myMax());               // 0
    console.log(myMax(4,2,5,6));        // 6
    console.log(myMax(4,2,5,6,8,1,9));  // 9

  </script>

  <script>

    /*
      중첩된 함수
      1. 함수 안에 함수를 정의할 수 있다.
      2. 외부 함수는 내부 함수의 매개변수나 변수를 사용할 수 없다.
      3. 내부 함수는 외부 함수의 매개변수나 변수를 사용할 수 있다.

      클로저
      내부 함수의 수명이 외부 함수보다 길게 유지되는 JavaScript의 기능
      (일반적인 프로그래밍 언어는 외부함수 호출이 끝나면 내부 함수는 메모리 상에서 사라진다. 그러므로 내부 함수는 사용할 수 없게 된다.
       하지만 javascript는 함수의 중첩이 가능하므로 외부 함수 호출이 끝나도 내부 함수를 유지한다.
       이것을 클로저 라고 한다.)
    */

    // 중첩된 함수 확인
    function getAddSquare(x, y){
      function getSquare(a){
        return a * a;
      }
      return (getSquare(x) + getSquare(y));
    }
    var result = getAddSquare(3, 4);   // (3 * 3) + (4 * 4), 인자값의 제곱의 합을 구하기
    console.log(result);

    // 외부 함수와 내부 함수의 변수 사용
    function outer(a){
      // console.log(b); 외부 함수는 내부 함수의 변수를 사용할 수 없다.
      function inner(b){
        return a + b; // 내부 함수는 외부 함수의 변수를 사용할 수 있다.
      }
      return inner;
    }

    // outer(10)은 반환값이 inner 함수 이다.
    console.log(outer(10)); // inner 함수 정보 확인.
    
    // outer(10)(20); 즉, outer(10)(20) = (outer(10))(20) = inner(20)
    //        a   b
    console.log(outer(10)(20));

  </script>
    <script>
    
      // 함수를 반환하는 고차 함수
      // 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환한다.
  
      const counter = (function () {
      // 카운트 상태를 유지하기 위한 자유 변수
      let counter = 0;
      
      // 함수를 인수로 전달받는 클로저를 반환
      return function (aux) {
          counter = aux(counter);
          return counter;
        };
      }());
  
      // 보조 함수
      function increase(n) {
        return ++n;
      }
  
      // 보조 함수
      function decrease(n) {
        return --n;
      }
  
      // 보조 함수를 전달하여 호출
      console.log(counter(increase)) //1
      console.log(counter(increase)) //2
  
      // 보조 함수를 전달하여 호출
      console.log(counter(decrease)) //1
      console.log(counter(decrease)) //0
    </script>

</body>
</html>